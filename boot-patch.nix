{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.boot.loader.systemd-boot;
  windows = cfg.windows or {};

  # Decide where entries are written (same logic as the upstream module)
  bootMountPoint =
    if cfg.xbootldrMountPoint != null then cfg.xbootldrMountPoint
    else config.boot.efi.efiSysMountPoint;

  entriesDir = "${bootMountPoint}/loader/entries";

  # generate a small shell snippet for each windows entry
  perEntryScripts = builtins.concatStringsSep "\n\n"
    (mapAttrsToList (name: entry: let
        desired = "0_windows_${name}";
        default = "o_windows_${name}";
      in ''
        f="${entriesDir}/windows_${name}.conf"
        if [ -f "$f" ]; then
          # extract current sort-key (case-insensitive)
          current=$(${pkgs.coreutils}/bin/sed -n 's/^[[:space:]]*sort-key[[:space:]]\\+\\(.*\\)/\\1/pI' "$f" | ${pkgs.coreutils}/bin/head -n1 || true)
          # if there's no sort-key or it's the module default, replace/add ours
          if [ -z "$current" ] || [ "$current" = "${default}" ]; then
            if ${pkgs.coreutils}/bin/grep -qi '^[[:space:]]*sort-key[[:space:]]' "$f"; then
              ${pkgs.coreutils}/bin/sed -i 's/^[[:space:]]*sort-key.*/sort-key ${desired}/I' "$f"
            else
              printf "\nsort-key ${desired}\n" >> "$f"
            fi
          fi
        fi
      '') windows);

in {
  # No options added â€” this is a small behavior module.
  config = {
    system.activationScripts."systemd-boot-windows-first" = {
      text = ''
        #!/bin/sh -e
        # Ensure the boot mount point exists and the entries directory is present.
        if ! ${pkgs.coreutils}/bin/test -d "${bootMountPoint}"; then
          echo "Boot mount point ${bootMountPoint} does not exist; skipping windows sort-key patch" >&2
          exit 0
        fi

        ${pkgs.coreutils}/bin/mkdir -p "${entriesDir}"

        # Per-entry adjustments (generated by Nix)
        ${perEntryScripts}

        exit 0
      '';
    };
  };
}

